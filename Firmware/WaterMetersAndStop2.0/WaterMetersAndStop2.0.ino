//ВНИМАНИЕ! По умолчанию скетч настроен на работу с четырьмя счетчиками (2 холодных, 2 горячих) и двумя группами кранов. 
//При необходимости работы с одной парой стояков и двумя счетчиками закомментировать все отмеченные строки и изменить ряд значений, все указано в комментариях.

#include <EEPROM.h>                   //  Подключаем библиотеку для работы с EEPROM
#include <Wire.h>                     //  Подключаем библиотеку для работы с шиной I2C
#include <LiquidCrystal_I2C.h>        //  Подключаем библиотеку для работы с LCD дисплеем по шине I2C
LiquidCrystal_I2C lcd(0x27,20,4);     //  Объявляем  объект библиотеки, указывая параметры дисплея (адрес I2C = 0x27, количество столбцов = 20, количество строк = 4)
#include <GyverButton.h>              //  Подключаем библиотеку для работы с кнопкой
GButton butt1(16);                    //  Пин кнопки подсветка/сброс

//Установка начальных показаний счетчиков. Внимание: значения сравниваются с таковыми из памяти устройства. Если значение в памяти больше, данные цифры ничего не изменят.
//При наличии только двух счетчиков замените последние цифры нулями, можно изменить размера массива на [2] для экономии памяти.
//При необходимости корректировки начальных показаний в сторону уменьшения либо их обнуления при замене счетчика сначала обнулите EEPROM, скетч для этого легко ищется в сети.
//Перед самой первой прошивкой рекомендуется обнулить EEPROM.
float counterstart[4] = {0, 20.45, 0, 8.78}; //Начальные показания через запятую: ХВС1, ГВС1, ХВС2, ГВС2 с точностью до сотых долей кубометра. Целая часть от дробной отделяется точкой.

float counter[4][4]; //массив в котором хранятся все данные счетчиков в виден таблицы 4 строки * 4 столбца. Каждому счетчику соответствует своя строка.
//При наличи двух счетчиков можно изменить размер массива на [2][4] для экономии памяти. 
//В столбцах первое значение - текущие показания, второе - показания в EEPROM, третье - текущие сбрасываемые показания, четвертое - сбрасываемые показания в EEPROM

bool meter_flag[4]; //массив служебных флагов для функции подавления дребезга герконов счетчиков. 
//При наличии двух счетчиков можно изменить размера массива на [2] для экономии памяти.

bool Light = 0; //флаг подсветки дисплея
uint32_t last_press = 0; //переменная таймера антидребезга
uint32_t timer1 = 0; //переменная таймера автопроворота
uint32_t leak1_timer; //переменная таймера срабатывания первой группы датчиков
uint32_t leak2_timer; //переменная таймера срабатывания второй группы датчиков, закомментировать при их отсутствии
uint32_t tone_timer; //переменная таймера сирены
uint32_t display_timer = 0; //переменная таймера обновления информации на дисплее
bool manual_flag = 0; //служебный флаг нажатия кнопки ручного режима
bool manual_mode = 0; //флаг включения ручного режима
bool water1_leak = false; //флаг авария первая группа
bool water2_leak = false; //флаг авария вторая группа, закомментировать при отсутствии
bool leak1_flag = false; //флаг срабатывания первой группы датчиков
bool leak2_flag = false; //флаг срабатывания второй группы датчиков, закомментировать при их отсутствии
byte water1_open; //флаг открытия кранов первой группы, 0 - закрыто, 1 - открыто
byte water2_open; //флаг открытия кранов второй группы, 0 - закрыто, 1 - открыто, закомментировать при их отсутствии
bool water1; //служебный флаг нажатия кнопки управления группой кранов 1
bool water2; //служебный флаг нажатия кнопки управления группой кранов 2, закомментировать при их отсутствии
bool autoturn = false; //флаг включения функции автопроворота кранов
bool tone_flag; //флаг сирены

void setup() {
  
  butt1.setDebounce(100);        // настройка антидребезга кнопки дисплея (по умолчанию 80 мс)
  butt1.setTimeout(5000);        // настройка таймаута на удержание (по умолчанию 500 мс)
  butt1.setClickTimeout(300);   // настройка таймаута между кликами (по умолчанию 300 мс)
  // HIGH_PULL - кнопка подключена к GND, пин подтянут к VCC (PIN --- КНОПКА --- GND)
  // LOW_PULL  - кнопка подключена к VCC, пин подтянут к GND
  butt1.setType(HIGH_PULL);
  // NORM_OPEN - нормально-разомкнутая кнопка
  // NORM_CLOSE - нормально-замкнутая кнопка
  butt1.setDirection(NORM_OPEN);
  
 pinMode(2, INPUT_PULLUP); //вход счетчика ХВС 1
 pinMode(3, INPUT_PULLUP); //вход счетчика ГВС 1
 pinMode(4, INPUT_PULLUP); //вход счетчика ХВС 2, закомментировать при отсутствии 
 pinMode(5, INPUT_PULLUP); //вход счетчика ГВС 2, закомментировать при отсутствии
 pinMode (6, INPUT_PULLUP); //вход датчиков группа 1
 pinMode (7, INPUT_PULLUP); //вход датчиков группа 2, закомментировать при их отсутствии
 pinMode (8, INPUT_PULLUP); //вход кнопки кранов группа 1
 pinMode (9, INPUT_PULLUP); //вход кнопки кранов группа 2, закомментировать при их отсутствии
 pinMode (10, INPUT_PULLUP); //вход кнопки активации ручного режима
 pinMode (11, OUTPUT); //выход реле кранов группа 1
 pinMode (12, OUTPUT); //выход реле кранов группа 2, закомментировать при отсутствии
 pinMode (13, OUTPUT); //выход на светодиод индикации включения ручного режима
 pinMode (14, OUTPUT); //выход на светодиод индикации аварии
 pinMode (15, OUTPUT); //выход на динамик
  
//проверка состояния кранов до отключения питания
 EEPROM.get(150, water1_open);  //читаем данные из EEPROM - была ли открыта группа кранов 1
 EEPROM.get(151, water2_open); //читаем данные из EEPROM - была ли открыта группа кранов 2, закомментировать при отсутствии

//Установка начала отсчета при запуске
 for (int i = 0; i < 4; i++) {  //для двух счетчиков заменить 4 на 2
 EEPROM.get(0+16*i, counter[i][0]); // читаем данные из EEPROM
 EEPROM.get(64+16*i, counter[i][2]); // читаем данные из EEPROM 
 if (counter[i][0] < counterstart[i])  //сравниваем данные из EEPROM с начальными показаниями 
 {
 counter[i][0] = counterstart[i]; //если значение в памяти меньше, отсчет начинается со стартового значения
 EEPROM.put(16*i, counterstart[i]); //запись начального значения в память 
 }
 } 

 lcd.init();    // Инициализация lcd             
 }

void loop() {

//БЛОК АКВАСТОРОЖА

 if (autoturn == false) { 
 digitalWrite(11, water1_open); //открываем-закрываем краны группы 1 в зависимости от состояния флага open
 digitalWrite(12, water2_open); //открываем-закрываем краны группы 2 в зависимости от состояния флага open, закомментировать при их отсутствии
 }
 
 digitalWrite(13, manual_mode); //включаем-выключаем индикатор ручного режима
 
 if (water1_leak == true || water2_leak == true) {  //если случилась авария, при отсутствии 2 группы убрать || water2_leak == true
  digitalWrite(14, 1);  //включаем сигнализатор аварии
  if (tone_flag == false && millis() - tone_timer > 500) {  //запускаем сирену
  tone(15, 400); 
  tone_flag = true;
  tone_timer = millis();
  } 
  if (tone_flag == true && millis() - tone_timer > 500) {
    tone(15, 800);  
    tone_flag = false;
    tone_timer = millis();
  }
 }
 if (water1_leak == false && water2_leak == false) { //при отсутствии второй группы убрать && water2_leak == false
  digitalWrite(14, 0); //выключаем сигнализатор аварии
  noTone(15);
 }

 //включаем-выключаем ручной режим
   if (!digitalRead(10) == 1 && manual_flag == 0 && millis() - last_press > 100) { 
    manual_flag = 1;
    manual_mode = !manual_mode;
    last_press = millis();
    }
    if (!digitalRead(10) == 0 && manual_flag == 1) {
    manual_flag = 0;
    }
 
 //автоматический режим 
  if (manual_mode == false) {   
    if (digitalRead(6) == 0 && leak1_flag == false) {   //опрос датчиков 1 группы
      leak1_timer = millis();
      leak1_flag = true;
    }
      if (leak1_flag == true && millis() - leak1_timer > 5000) { 
      water1_leak = true;
      water1_open = 0;
      EEPROM.put(150, water1_open);
      }
    if (digitalRead(6) == 1 && leak1_flag == true) {   
       leak1_flag = false;
    }
    
     if (digitalRead(7) == 0 && leak2_flag == false) {   //опрос датчиков 2 группы, при отсутствии закомментировать весь блок начиная с этой и...
      leak2_timer = millis();
      leak2_flag = true;
    }
      if (leak2_flag == true && millis() - leak2_timer > 5000) { 
      water2_leak = true;
      water2_open = 0;
      EEPROM.put(151, water2_open);
      }
    if (digitalRead(7) == 1 && leak2_flag == true) {   
       leak2_flag = false;
    }                                                    // ...по данную строку
  }
  
   //ручной режим
  if (manual_mode == true) {             
    water1_leak = false; //отключаем режим аварии
    water2_leak = false; //при отсутствии второй  группы закомментировать
    noTone(15);
   
    if (!digitalRead(8) == 1 && water1 == 0 && millis() - last_press > 100) {  //управление краном 1
    water1 = 1;
      if (water1_open == 1) {
      water1_open = 0;
    }
      else {
      water1_open = 1;
    }
      EEPROM.put(150, water1_open);
      last_press = millis();
    }
   if (!digitalRead(8) == 0 && water1 == 1) {
    water1 = 0;
    }
   
    if (!digitalRead(9) == 1 && water2 == 0 && millis() - last_press > 100) {   //управление краном 2, при отсутствии закомментировать весь блок начиная с этой и...
    water2 = 1;
      if (water2_open == 1) {
      water2_open = 0;
    }
      else {
      water2_open = 1;
    }
      EEPROM.put(151, water2_open);
      last_press = millis();
    }
    if (!digitalRead(9) == 0 && water2 == 1) {
    water2 = 0;
    }                                                       // ...по данную строку
  }

//автоматический проворот крана 1 раз в ~3 недели. Статус флагов открытия не меняем, чтобы бывшие открытыми краны затем автоматически открылись.
//Функция активна только при открытых кранах.
  if ((millis() - timer1) > 2147483647) {  
    if (water1_open == 1) {  
      digitalWrite(11, 0);  //закрываем первый кран если он открыт
      autoturn = true;
    }
    if (water2_open == 1) {  //при отсутствии группы 2 закомментировать весь блок начиная с этой и...
      digitalWrite(12, 0);  //закрываем второй кран если он открыт
      autoturn = true;
    }                       // ...по данную строку
    timer1 = millis();
  }
  if (autoturn == true && (millis() - timer1) > 30000) {
    autoturn = false;
    }

//БЛОК РЕГИСТРАТОРА СЧЕТЧИКОВ

 //Основной цикл обработки данных со счетчиков     
 for (int i = 0; i < 4; i++) {  //при двух счетчиках изменить цифру 4 на 2
   if (!digitalRead(i+2) == 1 && meter_flag[i] == 0 && millis() - last_press > 100) { 
    meter_flag[i] = 1; 
    counter[i][0] = counter[i][0] + 0.01;
    counter[i][2] = counter[i][2] + 0.01;
    last_press = millis();
    }
    if (!digitalRead(i+2) == 0 && meter_flag[i] == 1) {
    meter_flag[i] = 0;
    }
  EEPROM.get(16*i, counter[i][1]); //вызываем записанное число из EEPROM
  if (counter[i][0] - counter[i][1] >= 0.1) //сравниваем текущее значение счетчика с данными в EEPROM
  {
  EEPROM.put(16*i, counter[i][1]); //записываем новые данные в память через каждые 10 импульсов - экономим ресурс EEPROM
  }
  EEPROM.get(64+16*i, counter[i][3]); //вызываем записанное число из EEPROM
    if (counter[i][2] - counter[i][3] >= 0.1) //сравниваем текущее значение счетчика с данными в EEPROM
  {
  EEPROM.put(64+16*i, counter[i][2]); //записываем новые данные в память через каждые 10 импульсов - экономим ресурс EEPROM
  }
}
 
 //Включаем/выключаем подсветку дисплея и делаем сброс по длительному нажатию

  butt1.tick();  // обязательная функция отработки кнопки. Должна постоянно опрашиваться
 
 if (butt1.isHolded()) {  //если кнопка удерживается
   for (int i = 0; i < 4; i++) { //при двух счетчиках изменить цифру 4 на 2
    counter[i][2] = 0;  //сбрасываем данные третьего столбца массива в ноль
    EEPROM.put(64+16*i, counter[i][2]); //пишем все в EEPROM
   }
  }

  if (butt1.isSingle()) { //включение-выключение подсветки по одинарному нажатию. При включении дополнительно перерисовываем дисплей.
    if (Light == false) {
    Light = true; 
    lcd.clear();  //очистка экрана для профилактики либо убирания артефактов
    displayShow(); //выводим показания на экран
   } else {
     Light = false;
 }
}  

  if (butt1.isTriple()) //запись в EEPROM по тройному клику (использовать например перед принудительной перезагрузкой чтобы не потерять данные)
  {
    lcd.clear();
    lcd.setCursor(0, 0);
    // пишем всё в EEPROM
    for (int i = 0; i < 4; i++) { //при двух счетчиках изменить цифру 4 на 2
    EEPROM.put(0+16*i, counter[i][0]);
    EEPROM.put(64+16*i, counter[i][2]);
     }
    lcd.print("Stored");
  }
  
  //Отображаем информацию на дисплее
   lcd.setBacklight(Light);
   if (millis() - display_timer >= 60000) { //обновляем 1 раз в минуту - для счетчиков вполне достаточно. При необходимости корригируем число.
    display_timer = millis(); 
    displayShow();
   }

 //сброс значений, зависящих от millis, при переполнении и обнулении таймера. Необходимо для корректной работы.
  if (last_press > millis()) {
    last_press = millis();
  }
  if (timer1 > millis()) {
    timer1 = millis();
  }
   if ( display_timer > millis()) {
     display_timer = millis();
  }
  
}
   
void displayShow() {  //функция вывода данных на дисплей
   lcd.setCursor(0, 0);     // устанавливаем курсор в 0-ом столбце, 1 строке (начинается с 0)
   lcd.print("Cold1 ");
   lcd.setCursor(0, 1);     // устанавливаем курсор в 0-ом столбце, 2 строке (начинается с 0)
   lcd.print("Hot1  ");
   lcd.setCursor(0, 2);     // устанавливаем курсор в 0-ом столбце, 3 строке (начинается с 0).  При двух счетчиках закомментировать блок начиная с этой...
   lcd.print("Cold2 ");
   lcd.setCursor(0, 3);     // устанавливаем курсор в 0-ом столбце, 4 строке (начинается с 0)
   lcd.print("Hot2  ");                                                                        // ... и по данную строку.
   for (int i = 0; i < 4; i++) { //выводим данные из массива. При двух счетчиках меняем 4 на 2
   lcd.setCursor(6, i);  
   lcd.print(counter[i][0]);
   lcd.setCursor(14, i);
   lcd.print(counter[i][2]);
   }
}
